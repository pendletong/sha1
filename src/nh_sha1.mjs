/*
    noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com)
    
    steps to reproduce:

    1. git clone git@github.com:paulmillr/noble-hashes.git
    2. cd noble-hashes
    3. esbuild ./src/sha2.ts --bundle --platform=neutral --minify    

*/
function _(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function m(t,...n){if(!_(t))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(t.length))throw new Error(`Uint8Array expected of length ${n}, not of length=${t.length}`)}function w(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function U(t,n){m(t);let e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}var I=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;var l=t=>new DataView(t.buffer,t.byteOffset,t.byteLength);var x=(t,n)=>t<<n|t>>>32-n>>>0,D=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function B(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function A(t){return typeof t=="string"&&(t=B(t)),m(t),t}var h=class{clone(){return this._cloneInto()}},V={}.toString;function L(t){let n=s=>t().update(A(s)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function O(t,n,e,s){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,s);let i=BigInt(32),r=BigInt(4294967295),u=Number(e>>i&r),c=Number(e&r),o=s?4:0,a=s?0:4;t.setUint32(n+o,u,s),t.setUint32(n+a,c,s)}var E=(t,n,e)=>t&n^~t&e,H=(t,n,e)=>t&n^t&e^n&e,g=class extends h{constructor(e,s,i,r){super();this.blockLen=e;this.outputLen=s;this.padOffset=i;this.isLE=r;this.buffer=new Uint8Array(e),this.view=l(this.buffer)}buffer;view;finished=!1;length=0;pos=0;destroyed=!1;update(e){w(this);let{view:s,buffer:i,blockLen:r}=this;e=A(e);let u=e.length;for(let c=0;c<u;){let o=Math.min(r-this.pos,u-c);if(o===r){let a=l(e);for(;r<=u-c;c+=r)this.process(a,c);continue}i.set(e.subarray(c,c+o),this.pos),this.pos+=o,c+=o,this.pos===r&&(this.process(s,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){w(this),U(e,this),this.finished=!0;let{buffer:s,view:i,blockLen:r,isLE:u}=this,{pos:c}=this;s[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>r-c&&(this.process(i,0),c=0);for(let p=c;p<r;p++)s[p]=0;O(i,r-8,BigInt(this.length*8),u),this.process(i,0);let o=l(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=a/4,y=this.get();if(f>y.length)throw new Error("_sha2: outputLen bigger than state");for(let p=0;p<f;p++)o.setUint32(4*p,y[p],u)}digest(){let{buffer:e,outputLen:s}=this;this.digestInto(e);let i=e.slice(0,s);return this.destroy(),i}_cloneInto(e){e||=new this.constructor,e.set(...this.get());let{blockLen:s,buffer:i,length:r,finished:u,destroyed:c,pos:o}=this;return e.length=r,e.pos=o,e.finished=u,e.destroyed=c,r%s&&e.buffer.set(i),e}};var d=new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),b=new Uint32Array(80),T=class extends g{A=d[0]|0;B=d[1]|0;C=d[2]|0;D=d[3]|0;E=d[4]|0;constructor(){super(64,20,8,!1)}get(){let{A:n,B:e,C:s,D:i,E:r}=this;return[n,e,s,i,r]}set(n,e,s,i,r){this.A=n|0,this.B=e|0,this.C=s|0,this.D=i|0,this.E=r|0}process(n,e){for(let o=0;o<16;o++,e+=4)b[o]=n.getUint32(e,!1);for(let o=16;o<80;o++)b[o]=x(b[o-3]^b[o-8]^b[o-14]^b[o-16],1);let{A:s,B:i,C:r,D:u,E:c}=this;for(let o=0;o<80;o++){let a,f;o<20?(a=E(i,r,u),f=1518500249):o<40?(a=i^r^u,f=1859775393):o<60?(a=H(i,r,u),f=2400959708):(a=i^r^u,f=3395469782);let y=x(s,5)+a+c+f+b[o]|0;c=u,u=r,r=x(i,30),i=s,s=y}s=s+this.A|0,i=i+this.B|0,r=r+this.C|0,u=u+this.D|0,c=c+this.E|0,this.set(s,i,r,u,c)}roundClean(){b.fill(0)}destroy(){this.set(0,0,0,0,0),this.buffer.fill(0)}},W=L(()=>new T);export{W as sha1};
